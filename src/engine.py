#!/usr/bin/env python
# -*- coding: utf-8 -*-
import copy
import logging
import multiprocessing
import os
import select
import sys
import time
sys.path.append(os.path.abspath('src'))
from eventtype import EventType
from eventsocket import EventSocket
from endgameevent import EndGameEvent
from gameconfig import GameConfig
from gameobject import GameObject
from gamestate import GameState
from gameevent import GameEvent
from gamerecord import GameRecord
from nullrenderer import NullRenderer
from nullkeyboard import NullKeyboard
import tpsocket
import tplogger
logger = tplogger.getTPLogger('engine.log', logging.DEBUG)
'''The gameengine module.

Notes on lag compensation.
We want the user to experience as little  network latency as possible. To 
achieve this, we can perform lag compensation on the server. The server and 
client keep a record of the game state and inputs for each frame up to about 2L 
frames, where L is the latency (more precisely, the number of frames that would 
be played in that time). When the client presses a key, the game responds 
immediately. At the same time, the client sends the key press together with the 
frame number f to the server. After about L frames, the server receives these. 
To compensate for the lag L, the server rewinds to the frame when the key was 
pressed and replays all the key events received since that time. The server 
then sends back 'relevant data to represent the state' and the frame number 
f + L. The client receives 
these after another L frames. The client can then similarly rewind to frame f 
and replay any keys since that time to compute the current state.

There are at least three approaches to what the server could send. One is 
sending the state resulting from the replay. 

There is a problem when the client enters a key between frames f and f + L. 
When the client receives the state from the server at f + 2L, we only rewind 
to f + L. Since what we receive is only a response to events up to time f, 
any event between f and f + L, say f + e  will not be taken into account. To 
the client, it will look as if that event was 'cancelled' - until the client 
receives the reply for it at time f + e + 2L. A workaround would be to 
prohibit key presses for L frames after the last.

Another approach is to send a list of pairs, each pair a frame number and the 
corresponding events at that frame. This solution avoids the need for key 
press prohibition above. However, if the server takes longer than expected to 
send the reply (i.e. 2L frames), the client may not be able to rewind far 
enough into the past to correctly reproduce the state. To avoid this, the 
client must stall the game if the game record has been filled to 2L frames 
since the last reply from the server.

Alternatively, the server could send both keys and state, to get the best of 
both.

At the moment, the first solution is preferred for its simplicity.

Notes on mixing local and online multiplayer.
We cannot have more than one player on each client. This is because the 
required key event cool-down time applies to events generated by any player on 
a given client. In other words, if two players are playing on one machine,
if one presses a key, the other will have to wait cool-down frames before 
pressing a key.

Notes on buffer delay.
While lag compensation reduces lag for the object controlled by a client,
objects controlled by other players will appear jerky. We can cause key events 
to be delayed by some number of frames before they are allowed to take effect 
(but the key will be sent to the server immediately.) By setting the delay to 
be 2L (the round-trip time), we can eliminate the effect of network latency for 
all objects. In practice, 2L may be too large to tolerate, so we choose a 
smaller delay D. The delay experienced by a client noticing an event from 
another client will then be 2L - D.
D should be set less than L; otherwise, it will get buffered by the server for 
about D - L frames.

Notes on interpolation.
The renderer can linearly interpolate between the previous frame and the 
current frame for a smoother result. This allows us to lower the logic update
rate of the engine (which in turn lowers the server buffer size) without 
sacrificing smoothness.
'''

class GameEngine(object):
    '''The game engine.

    This class contains the logic and interfaces for the game. When run as the 
    client, it takes input from the keyboard and state updates from the server. 
    When run as the server, it takes game events sent by clients.

    The client and server sockets are event sockets (eventsocket.py).

    Attributes:
    renderer           -- The renderer to use. The default is the NullRenderer 
                          which renders nothing.
    keyboard           -- The keyboard to get input from. The default is the
                          NullKeyboard which gets nothing.
    last_key_frame     -- (Deprecate) The time of the last game event sent to 
                          the server. 
    last_key_frames    -- The time of the last key. Used in local mode.
    key_cool_down_time -- The minimum frame between game events per player.
                          See above notes on lag compensation for details.
    player_id          -- The player ID of the client.
    is_client          -- True if this is running as a client.
    is_server          -- True if this is running as the server.
    is_local           -- True if this is running in local mode.
    clients            -- The list of client sockets.
    server             -- The socket connected to the server.
    key_bindings       -- The key to use for each player. A negative value
                          means the player has no key binding.
    buffer_delay-- The number of frames of delay to apply to key events.
    key_buffer         -- A list of future key events. The events for the 
                          current frame is (frame % buffer_delay)
    do_interpolate     -- Set to True if the renderer should interpolate.
    buffer_size        -- The size of the game state buffer.
    histories          -- N-bit record of key presses for each player.
    history_size       -- The number of bits of history.
    should_apply_gravity -- Gravity is enabled if True.
    '''

    K_SPACE = 32
    def __init__(self):
        self.state = GameState()
        self.renderer = NullRenderer()
        self.keyboard = NullKeyboard()
        self.last_key_frames = [0, 0, 0]
        self.key_cool_down_time = 10
        self.player_id = 0
        self.is_client = False
        self.is_server = False
        self.is_local = False
        self.clients = []
        self.server = None
        self.key_bindings = [32, -1, -1]
        self.buffer_delay = 0
        self.key_buffer = [0]*self.buffer_delay # to do: deprecate
        self.do_interpolate = False
        self.buffer_size = 300
        self.should_apply_gravity = True
        self.should_apply_collision = True
        self.paddle_flap_vel = -12
        self.ball_flap_vel = -8

    def RoleToEvent(self, role):
        '''Convert role into its corresponding game event.
        '''
        if role == GameState.ROLE_LEFT_PADDLE:
            return GameEvent.EVENT_FLAP_LEFT_PADDLE
        elif role == GameState.ROLE_RIGHT_PADDLE:
            return GameEvent.EVENT_FLAP_RIGHT_PADDLE
        elif role == GameState.ROLE_BALL:
            return GameEvent.EVENT_FLAP_BALL
        return GameEvent.EVENT_NO_OP

    def GetKeyboardEvents(self, keys, s):
        '''Get the flag for the currently pressed keys.

        The keyboard events are represented by key event codes, defined in 
        gameevent.py.

        Key presses during cool-down periods are suppressed.

        Argument:
        keys  -- The current state of the keyboard represented as a 323-tuple 
                 of 0 and 1.
        s     -- The game state.

        Return value:
        A flag of keyboard event codes.
        '''
        flag = 0
        ESCAPE = 27
        if keys[ESCAPE]:
            raise Exception('Exited game.')
        for i in range(0, 3):
            if self.key_bindings[i] < 0:
                continue
            if not keys[self.key_bindings[i]]:
                continue
            if s.frame - self.last_key_frames[i] < self.key_cool_down_time:
                logger.debug('suppressed un-cooled key')
                continue
            self.last_key_frames[i] = s.frame
            flag |= self.RoleToEvent(s.roles[i])

        return flag

    def EndGame(self, s):
        s.should_render_score = True
        s.should_render_crown = False
        s.is_ended = True

    def HandleEndGameEvent(self, s, evt):
        s.scores[0] = evt.score_0
        s.scores[1] = evt.score_1
        s.scores[2] = evt.score_2
        self.EndGame(s)

    def GetServerEvent(self, svr, s):
        '''Get state update from the server.
        Also handle end of game events.

        Argument:
        svr -- The socket connected to the server.
        s   -- The game state.

        Return value:
        The game state sent by the server, or None if no update was 
        available.
        '''
        if svr == None:
            return None
        evt = None
        try:
            evt = svr.ReadEvent()
        except Exception as e:
            logger.exception(e)
            logger.info('Closing connection to server.')
            self.server.Close()
            self.server = None
        if evt == None:
            return None
        if evt.event_type == EventType.STATE_UPDATE:
            logger.debug('received update {0}'.format(evt.frame))
            return evt
        elif evt.event_type == EventType.END_GAME:
            logger.debug('received end of game')
            self.HandleEndGameEvent(s, evt)
            return self.GetServerEvent(svr, s)

    def GetClientEvents(self, clients, current_frame):
        '''Read client sockets for keyboard events.

        Arguments:
        clients -- A list of client sockets.
        current_frame -- The frame number of the server. If an event happens in 
        the future, it should be put back.

        Return value:
        A list of game events.
        '''
        evts = []
        for c in list(clients):
            evt = None
            try:
                evt = c.ReadEvent()
            except Exception as e:
                logger.exception(e)
                logger.info('closing connection to client {0}'.format( \
                        c.GetPeerName()))
                c.Close()
                clients.remove(c)
            # Check if the event happens in the future.
            if evt == None:
                continue
            # Ignore non-key events.
            if evt.event_type != EventType.KEYBOARD:
                continue
            if evt.frame > current_frame:
                logger.debug('unreading future event')
                c.UnreadEvent()
                continue
            evts.append(evt)
            logger.debug('received key event {0}'.format(evt.frame))
            
        return evts

    def SendStateUpdate(self, clients, s):
        '''Send a partial state to the connected sockets in clients.

        Arguments:
        clients -- The clients to send to.
        s      -- The game state to send.'''
        logger.debug('sending state update {0}'.format(s.frame))
        for c in list(clients):
            try:
                c.WriteEvent(s)
            except:
                logger.info('closing connection to client {0}'.format( \
                        c.GetPeerName()))
                c.Close()
                clients.remove(c)
        

    def SendKeyboardEvents(self, svr, frame, keys):
        '''Serialize a game event and send to the server.

        Arguments:
        svr  -- The server socket to send to.
        frame -- The frame number of the event.
        keys -- A flag of game event codes, defined in gameevent.py'''
        if svr == None:
            return
        logger.debug('sending key event {0}'.format(frame))
        evt = GameEvent()
        evt.keys = keys
        evt.frame = frame
        try:
            svr.WriteEvent(evt)
        except:
            logger.info('closing connection to server')
            self.server.Close()
            self.server = None

    def SendEndGameEvent(self, clients, s):
        '''Send the end of game event to each client.
        Arguments:
        clients -- The list of client EventSocket.
        s       -- The game state.
        '''
        evt = EndGameEvent()
        evt.score_0 = s.scores[0]
        evt.score_1 = s.scores[1]
        evt.score_2 = s.scores[2]
        for c in list(clients):
            try:
                c.WriteEvent(evt)
            except Exception as e:
                logger.exception(e)
                c.Close()
                clients.remove(c)

    def ApplyGravity(self, s):
        '''Apply gravity to the paddles and the ball

        Arguments:
        s -- the game state'''
        PADDLE_TERM_VELOCITY = 16
        BALL_TERM_VELOCITY   = 32

        if s.paddle_left.vel_y < PADDLE_TERM_VELOCITY:
            s.paddle_left.vel_y += 1
            
        if s.paddle_right.vel_y < PADDLE_TERM_VELOCITY:
            s.paddle_right.vel_y += 1
            
        if s.ball.vel_y < BALL_TERM_VELOCITY:
            s.ball.vel_y += 1
            
        

    def ApplyEvents(self, s, keys):
        '''Apply the effect of events to the game state.

        keys should be an OR'd flag consisting of the following values defined 
        in gameevent.py:
        EVENT_FLAP_NO_OP         -- Do nothing.
        EVENT_FLAP_LEFT_PADDLE
        EVENT_FLAP_RIGHT_PADDLE
        EVENT_FLAP_BALL          -- Update the velocity.

        More events could be defined in the future.

        Arguments:
        s    -- the game state.
        evts -- a list of events to apply.'''

        if keys & GameEvent.EVENT_FLAP_LEFT_PADDLE:
            s.paddle_left.vel_y = self.paddle_flap_vel
        if keys & GameEvent.EVENT_FLAP_RIGHT_PADDLE:
            s.paddle_right.vel_y = self.paddle_flap_vel
        if keys & GameEvent.EVENT_FLAP_BALL:
            s.ball.vel_y = self.ball_flap_vel

    def ApplyLogic(self, s):
        '''Update positions.
        
        Arguments:
            s    -- the state of the game.'''

        # update positions 
        s.ball.pos_x += s.ball.vel_x
        s.ball.pos_y += s.ball.vel_y
        s.paddle_left.pos_y += s.paddle_left.vel_y
        s.paddle_right.pos_y += s.paddle_right.vel_y

    def ApplyCollision(self, s):
        '''
        Handle collisions.
        '''
        if s.paddle_left.IsCollidingWith(s.ball):
            s.paddle_left.AlignRight(s.ball)
            s.ball.vel_x = - s.ball.vel_x
            
        if s.paddle_right.IsCollidingWith(s.ball):
            s.paddle_right.AlignLeft(s.ball)
            s.ball.vel_x = - s.ball.vel_x
            
        if s.ball.IsCollidingWith(s.ball_wall_top):
            s.ball_wall_top.AlignBottom(s.ball)
            s.ball.vel_y = - s.ball.vel_y
            
        if s.ball.IsCollidingWith(s.ball_wall_bottom):
            s.ball_wall_bottom.AlignTop(s.ball)
            s.ball.vel_y = - s.ball.vel_y
            
        if s.paddle_left.IsCollidingWith(s.paddle_wall_top):
            s.paddle_wall_top.AlignBottom(s.paddle_left)
            s.paddle_left.vel_y = - s.paddle_left.vel_y
            
        if s.paddle_right.IsCollidingWith(s.paddle_wall_top):
            s.paddle_wall_top.AlignBottom(s.paddle_right)
            s.paddle_right.vel_y = - s.paddle_right.vel_y
            
        if s.paddle_left.IsCollidingWith(s.paddle_wall_bottom):
            s.paddle_wall_bottom.AlignTop(s.paddle_left)
            s.paddle_left.vel_y = - s.paddle_left.vel_y
            
        if s.paddle_right.IsCollidingWith(s.paddle_wall_bottom):
            s.paddle_wall_bottom.AlignTop(s.paddle_right)
            s.paddle_right.vel_y = - s.paddle_right.vel_y
            
        if s.ball.IsCollidingWith(s.goal_left):
            s.ball.pos_x = ( s.goal_right.pos_x + s.goal_left.pos_x ) // 2
            s.ball.pos_y = ( s.ball_wall_top.pos_y +
                    s.ball_wall_bottom.pos_y ) // 2
            s.ball.vel_x = - s.ball.vel_x
            s.ball.vel_y = 0
            if not s.is_ended:
                s.scores[s.players[GameState.ROLE_BALL]] += 1
                s.scores[ s.players[ GameState.ROLE_RIGHT_PADDLE ] ] += 1
            
        if s.ball.IsCollidingWith(s.goal_right):
            s.ball.pos_x = ( s.goal_right.pos_x + s.goal_left.pos_x ) // 2
            s.ball.pos_y = ( s.ball_wall_top.pos_y +
                    s.ball_wall_bottom.pos_y ) // 2
            s.ball.vel_x = - s.ball.vel_x
            s.ball.vel_y = 0
            if not s.is_ended:
                s.scores[s.players[GameState.ROLE_BALL]] += 1
                s.scores[ s.players[ GameState.ROLE_LEFT_PADDLE ] ] += 1

    def PlayFrame(self, s, keys):
        '''Move the game forward by one frame.

        Arguments:
        s    -- The game state.
        keys -- The flag for key events.'''
        if self.should_apply_gravity:
            self.ApplyGravity(s)
        self.ApplyEvents(s, keys)
        if self.should_apply_collision:
            self.ApplyCollision(s)
        self.ApplyLogic(s)
        s.frame += 1
        

    def RewindAndReplayWithState(self, auth_state, current_frame, rec):
        '''Rewind and replay the game from a given state.

        This method rewinds the game to auth_state.frame and replays inputs 
        starting from that frame until the current frame over auth_state. 
        auth_state will be changed.
        The inputs for the current frame are not handled here, so any events 
        must be applied to the result of this method.
        The inputs  are recorded in rec. 

        This method is intended to be used by the client receiving an 
        authoritative state auth_state from the server to correct the local 
        game state.

        Arguments:
        auth_state    -- The state to replay from. 
        current_frame -- The frame to replay to.
        rec           -- A game record.
        
        Return value:
        The game state resulting from the rewind and replay or None if 
        no rewind is possible.
        '''
        rewind = current_frame - auth_state.frame
        if rewind < 0:
            # The server is ahead of the client. Go to auth_state directly.
            rec.available = 0
            logger.debug('jumping to auth state')
            return auth_state
        if rewind > rec.available:
            # The state is too old for rewind.
            logger.debug('ignoring old state')
            return None
        rec.states[(rec.idx - rewind) % rec.size].key_flags |= \
                auth_state.key_flags
        for i in range(0, rewind):
            self.PlayFrame(auth_state,
                    rec.states[(rec.idx - rewind + i) % rec.size].key_flags)
            
        rec.available = rewind
        auth_state.key_flags = 0
        return auth_state
    
    def RewindAndReplayWithKey(self, s, evt, rec):
        '''Rewind and replay the game based on events in the past.

        This method is intended to be used by the server to correct its 
        authoritative state in response to key events sent by the client.

        This method updates the event records at frame evt.frame and updates
        all later states up to s.frame.

        s is set to the result of the rewind.

        Arguments:
        s             -- The game state of the server.
        evt           -- A game event to play.
        rec           -- A game record.

        '''
        rewind = s.frame - evt.frame
        if rewind < 0:
            # The client is ahead of the server. Ignore.
            # This should never happen if we are unreading events in
            # the method GetClientEvents().
            logger.debug('client is ahead - ignoring')
            return None
        if rewind > rec.available:
            # The event is too old to rewind. Ignore the event.
            # fix me:
            # The client needs to know the event was ignored, so return 
            # the previous frame?
            logger.debug('event too old to rewind')
            return None
        # Update the record
        rec.states[(rec.idx - rewind) % rec.size].key_flags |= evt.keys
        for i in range(0, rewind):
            idx = (rec.idx - rewind + i) % rec.size
            t = rec.states[(idx + 1) % rec.size]
            key_flags = t.key_flags
            rec.states[idx].Copy(t)
            self.PlayFrame(t, t.key_flags)
            t.key_flags = key_flags
            
        rec.states[rec.idx].Copy(s)
        # reset key_flags (some tests rely on this feature).
        s.key_flags = 0
        return s

    def RunFrameAsClient(self, s, rec):
        '''
        The main loop of the client.

        The client checks for updates from the server. If there isn't an update 
        available, the client plays a frame with the keys obtained from the 
        keyboard.

        If there is an update, it applies the rewind-replay. If the update 
        is for the current frame, the key_flags are added to those from the 
        keyboard. Then the frame is played.

        '''
        update = None
        k = self.keyboard.GetKeys()
        fresh_keys = self.GetKeyboardEvents(k, s)
        # Send fresh key events to server.
        if fresh_keys != 0:
            self.SendKeyboardEvents(self.server,
                    s.frame + self.buffer_delay, fresh_keys)
        if self.buffer_delay > 0:
            # Buffer delay.
            # Read from the buffer. Then buffer the current keys.
            buffer_idx = s.frame % self.buffer_delay
            keys = self.key_buffer[buffer_idx]
            self.key_buffer[buffer_idx] = fresh_keys
        else:
            # No delay.
            keys = fresh_keys
        # Get state update from the server.
        update = self.GetServerEvent(self.server, s)
        if update != None:
            # if the update is for the current frame, set the keys.
            if update.frame == s.frame:
                keys |= update.key_flags
            update = self.RewindAndReplayWithState(update, s.frame, rec)
            # if update is None, we should ignore it. Otherwise, update.
            if update != None:
                update.Copy(s)
            
        rec.AddEntry(s, keys)
        self.PlayFrame(s, keys)
        s.player_id = self.player_id
        

    def RunFrameAsServer(self, s, rec):
        '''
        The main loop of the server.

        The server first checks for events from the clients. If there isn't an 
        event available, the server plays a frame.
        
        If there is an event, it applies the rewind-replay for correction.
        The corrected state, along with any key events in the current frame,
        are sent to each client. Finally, the current frame is played.

        '''
        s.key_flags = 0
        keys = 0
        key_evts = self.GetClientEvents(self.clients, s.frame)
        # Amend the game record.
        applied_evts = []
        for evt in key_evts:
            if evt.frame == s.frame:
               keys |= evt.keys
            # Update the record with the new event, if applicable.
            if rec.ApplyEvent(s.frame, evt) == 0:
                applied_evts.append(evt)
            
        if len(applied_evts) > 0:
            # Sort the events by frame.
            sorted(applied_evts, key=lambda x: x.frame, reverse=False)
            # Call rewind using the earliest applicable event.
            evt = key_evts[0]
            self.RewindAndReplayWithKey(s, evt, rec)
            # Send state to clients.
            s.key_flags = keys
            self.SendStateUpdate(self.clients, s)
        
        rec.AddEntry(s, keys)
        self.PlayFrame(s, keys)

    def GetTargetFrame(self, now, start_time, start_frame, end_frame, 
            frame_rate):
        '''Compute the frame we should be on.
        This method is intended to be used in RunGame().
        Arguments:
        now -- The current time.
        start_time -- The time at the start of the run.
        start_frame -- The frame at the start of the run.
        end_frame   -- The frame at the end of the run.
        '''
        target = int(((now - start_time) * frame_rate) + start_frame)
        if target > end_frame:
            target = end_frame
        return target

    # UDP stuff BEGIN
    def GetCurrentFrame(self, start_time, frame_rate, now):
        '''Get the frame the server is on.
        Arguments:
        start_time -- Time at the start of game.
        frame_rate -- Frames per second.
        now        -- Current time.
        '''
        return int((now - start_time) * frame_rate)

    def RotateBits(self, bits, shift, size):
        '''
        Arguments:
        bits  -- Bits of length size.
        shift -- The bit positions to rotate right by.
        size  -- The length of bits.
        '''
        assert(shift <= size)
        valmax = 1 << size
        return (bits >> shift) | ((bits << (size-shift)) % valmax)

    def UpdateHistory(self, frame, keybits, update_frame, update, size):
        '''
        This method is intended to be used by a peer receiving key input 
        history to update its local state. The history is represented by a
        size-bit integer keybits and a frame number f. 
        The history represents inputs that occurred in frames 
        [f - size, f) excluding f. If g is a frame in this range, the
        (g % size)th bit of the history represents the input at frame g.

        update_frame must be less than frame.

        Arguments:
        frame        -- The frame associated with keybits.
        keybits      -- size-bits of keys.
        update_frame -- The frame associated with update. This must be
                        older than frame.
        update       -- size-bits of keys.
        size         -- The number of bits in history.

        Return value:
        An updated size-bit history of keys at frame.
        '''
        assert isinstance(frame, int)
        assert isinstance(keybits, int)
        assert isinstance(update_frame, int)
        assert isinstance(update, int)
        assert isinstance(size, int)
        assert update_frame <= frame
        # Rotate the oldest frame to the 0th bit.
        rot_keybits = self.RotateBits(keybits, frame % size, size)
        rot_update = self.RotateBits(update, update_frame % size, size)
        result = rot_keybits | (rot_update >> (frame - update_frame))
        return self.RotateBits(result, size - (frame % size), size)


    def BitsToEvent(self, state, bits):
        '''
        Arguments:
        state -- The GameState.
        bits  -- A list of bits, one for each player.

        Return value:
        The GameEvent corresponding to the bits.
        '''
        assert(len(bits) <= 3)
        evt = 0
        for i in range(0, len(bits)):
            evt |= self.RoleToEvent(state.roles[i]) * bits[i]
        return evt

    def GetBit(self, bits, n):
        '''
        Returm value:
        Get the nth least significant bit of bits.
        '''
        assert(n >= 0)
        return ((bits & (1 << n)) >> n)

    def RewindAndReplayBits(self, state, histories, rec, replay_from,
            replay_to, size):
        '''
        This method uses the histories of key inputs of each player to 
        compute the local game state. The game is played up to and 
        excluding frame replay_to. state and the states in rec are updated.

        replay_to is the frame associated with the entries in histories.

        Arguments:
        state        -- The GameState.
        histories    -- A list of size-bit histories.
        rec          -- The GameRecord.
        replay_from  -- The frame to rewind to and replay from.
        replay_to    -- The frame to play up to.
        size         -- The size of a history.
        '''
        assert rec != None
        assert replay_from >= 0
        # state.frame is not in rec, so state.frame != replay_from
        assert state.frame > replay_from
        assert state.frame - replay_from <= rec.available
        assert replay_from <= replay_to
        assert replay_to - replay_from <= size
        assert size > 0
        assert rec.size == size
        s = GameState()
        rec.states[replay_from % rec.size].Copy(s)
        assert(s.frame == replay_from)
        for i in range(replay_from, replay_to):
            n = i % size
            evt = self.BitsToEvent(s, [self.GetBit(histories[0], n),
                    self.GetBit(histories[1], n),
                    self.GetBit(histories[2], n)])
            self.PlayFrame(s, evt)
            rec.AddRecord(s)
        s.Copy(state)

    def ApplyUpdate(self, s, histories, rec, rewind_from, update_frame, 
            update_bits, size):
        '''
        Updates the GameState, GameRecord, and histories.

        Arguments:
        s         -- The GameState to update.
        histories -- A list of size-bit records to update.
        rec       -- The GameRecord.
        rewind_from -- The frame to rewind from.
        update_frame   -- The frame of update_bits.
        update_bits    -- A history bit list.
        size      -- Size of histories.
        '''
        assert s.frame >= 0 
        assert update_frame >= 0 
        assert len(histories) == len(update_bits) 
        # Find the newer history.
        old_frame = min(s.frame, update_frame)
        new_frame = max(s.frame, update_frame)
        if s.frame < update_frame:
            old_bits = histories
            new_bits = update_bits
        else:
            old_bits = update_bits
            new_bits = histories
        # Update histories.
        for i in range(0, len(histories)):
            histories[i] = self.UpdateHistory(new_frame, new_bits[i],
                    old_frame, old_bits[i], size)
        # Rewind and replay.
        self.RewindAndReplayBits(s, histories, rec, rewind_from, new_frame, 
                size)

    def IsAcked(self, frame, history, history_frame, size):
        '''
        Arguments:
        frame          -- The frame to check.
        history        -- A size-bit record of key inputs.
        history_frame  -- The frame after the last in history.
        size           -- The size of history.

        Return value:
        True if the bit corresponding to frame in history is 1 and False
        otherwise.
        '''
        assert isinstance(frame, int)
        assert isinstance(history, int)
        assert isinstance(history_frame, int)
        assert isinstance(size, int)
        assert frame >= 0
        assert history_frame >= 0
        if frame >= history_frame:
            # Too recent.
            return False
        if history_frame - frame > size:
            # Too old to tell.
            return False
        return self.GetBit(history, frame % size) == 1


    # UDP stuff END

    def RunGame(self, s, rec, max_frame, frame_rate):
        '''Run the game.

        This is the main game loop.

        Arguments:
        s       -- The game state to run the game from.
        rec     -- The game record for saving state and events.
        max_frame -- The number of frames to run the game for.
        frame_rate -- The number of frames to play per second.
        '''
        start_time = time.time()
        start_frame = s.frame
        end_frame = start_frame + max_frame
        logger.debug('playing {0} frames'.format(max_frame))
        while True:
            if s.frame >= end_frame:
                break
            # Compute the target current frame.
            target_frame = self.GetTargetFrame(time.time(), start_time,
                    start_frame, end_frame, frame_rate)
            if target_frame == s.frame:
                continue
            # Play a frame.
            if self.is_client:
                self.RunFrameAsClient(s, rec)
            elif self.is_server:
                self.RunFrameAsServer(s, rec)
            else:
                # This feature is used for testing.
                rec.AddEntry(s, 0)
                self.PlayFrame(s, 0)
            # Catch up.
            if s.frame < target_frame:
                continue
            # Do the rendering
            end_time = ((target_frame + 1 - start_frame) \
                    / float(frame_rate)) + start_time
            now = time.time()
            # Minus two because rec.idx is pointing to the next frame.
            self.renderer.Render(rec.states[(rec.idx - 2)%rec.size],
                    s, now, end_time)

    def RotateRoles(self, s):
        '''Rotate the roles of the players.
        Argument:
        s -- The game state.
        '''
        tmp = s.roles[1:]
        tmp.append(s.roles[0])
        s.roles = tmp
        for player_id in range(0, len(s.roles)):
            s.players[s.roles[player_id]] = player_id

    def PlayRound(self, s, rec, rotations, rotation_length, frame_rate):
        '''Play one round of the game, with each player playing every role.

        Argument:
        s -- The game state to start the round from.
        rotations -- The number of rotations in the round.
        rec -- The game record to record the game on.
        rotation_length -- The number of frames to play for each rotation.
        frame_rate -- The number of frames to play per second.
        '''

        logger.debug('starting round')
        for i in range(0, rotations):
            logger.debug('starting rotation')
            self.RunGame(s, rec, rotation_length, frame_rate)
            self.RotateRoles(s)

    def Play(self, s):
        '''
        Argument:
        s -- The game state.
        '''
        #player_size = s.player_size
        rotation_length = s.rotation_length
        frame_rate = s.frames_per_sec 
        rounds = s.rounds
        rec = GameRecord()
        # Pick an estimate for a value greater than 2L.
        rec.SetSize(self.buffer_size)

        for i in range(0, rounds):
            self.PlayRound(s, rec, 3, rotation_length, 
                    frame_rate)
            
        if self.is_server:
            self.SendEndGameEvent(self.clients, s)
        self.EndGame(s)
        # Keep the game running for a bit, to show the final score.   
        self.RunGame(s, rec, frame_rate * 30, frame_rate)

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='The triplepong game \
            engine.')
    parser.add_argument('-i', '--interpolate', action='store_true',
            default=False, help='Turn on renderer interpolation.')
    args = parser.parse_args()
    e = GameEngine()
    e.is_client = True
    e.is_server = False
    conf = GameConfig()
    conf.do_interpolate = args.interpolate
    conf.Apply(e)
    e.key_bindings = [32, 112, 113]
    from renderer import Renderer
    r = Renderer()
    r.Init()
    conf.ApplyRenderer(r)
    e.renderer = r
    e.keyboard = r
    e.Play(e.state)
    
