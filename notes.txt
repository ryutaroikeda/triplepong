TriplePong Networking Notes
8 Jan 2016

Notes on lag compensation.
We want the user to experience as little  network latency as possible. To 
achieve this, we can perform lag compensation on the server. The server and 
client keep a record of the game state and inputs for each frame up to about 2L 
frames, where L is the latency (more precisely, the number of frames that would 
be played in that time). When the client presses a key, the game responds 
immediately. At the same time, the client sends the key press together with the 
frame number f to the server. After about L frames, the server receives these. 
To compensate for the lag L, the server rewinds to the frame when the key was 
pressed and replays all the key events received since that time. The server 
then sends back 'relevant data to represent the state' and the frame number 
f + L. The client receives 
these after another L frames. The client can then similarly rewind to frame f 
and replay any keys since that time to compute the current state.

There are at least three approaches to what the server could send. One is 
sending the state resulting from the replay. 

There is a problem when the client enters a key between frames f and f + L. 
When the client receives the state from the server at f + 2L, we only rewind 
to f + L. Since what we receive is only a response to events up to time f, 
any event between f and f + L, say f + e  will not be taken into account. To 
the client, it will look as if that event was 'cancelled' - until the client 
receives the reply for it at time f + e + 2L. A workaround would be to 
prohibit key presses for L frames after the last.

Another approach is to send a list of pairs, each pair a frame number and the 
corresponding events at that frame. This solution avoids the need for key 
press prohibition above. However, if the server takes longer than expected to 
send the reply (i.e. 2L frames), the client may not be able to rewind far 
enough into the past to correctly reproduce the state. To avoid this, the 
client must stall the game if the game record has been filled to 2L frames 
since the last reply from the server.

Alternatively, the server could send both keys and state, to get the best of 
both.

At the moment, the first solution is preferred for its simplicity.

Notes on mixing local and online multiplayer.
We cannot have more than one player on each client. This is because the 
required key event cool-down time applies to events generated by any player on 
a given client. In other words, if two players are playing on one machine,
if one presses a key, the other will have to wait cool-down frames before 
pressing a key.

Notes on buffer delay.
While lag compensation reduces lag for the object controlled by a client,
objects controlled by other players will appear jerky. We can cause key events 
to be delayed by some number of frames before they are allowed to take effect 
(but the key will be sent to the server immediately.) By setting the delay to 
be 2L (the round-trip time), we can eliminate the effect of network latency for 
all objects. In practice, 2L may be too large to tolerate, so we choose a 
smaller delay D. The delay experienced by a client noticing an event from 
another client will then be 2L - D.
D should be set less than L; otherwise, it will get buffered by the server for 
about D - L frames.

Notes on interpolation.
The renderer can linearly interpolate between the previous frame and the 
current frame for a smoother result. This allows us to lower the logic update
rate of the engine (which in turn lowers the server buffer size) without 
sacrificing smoothness.

Handling loss:
Clear the bit records, copy the server state and bitrec, then replay.

Fix me:
- Make datagrams smaller.
-- Use frame numbers that wrap around.

